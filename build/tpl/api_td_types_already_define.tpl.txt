
#[doc(hidden)] pub struct _{{tgype.typen}}Builder { inner: {{tgype.typen}} }

impl _{{tgype.typen}}Builder {

  pub fn build(&self) -> {{tgype.typen}} { self.inner.clone() }

  {% for field in td.fields %}{% if field.native %}{% if field.name != 'td_name' %}{% if field.description %}/// {{field.description}}{% endif %}
  pub fn {{field.name}}{% if field.class_real == 'String' %}<S: AsRef<str>>{% endif %}(&mut self, {{field.name}}: {% if field.class_real == 'String' %}S{% else %}{{field.class_real}}{% endif %}) -> &mut Self {
    self.inner.td_origin_mut()._set_{{field.name}}({% if field.class_real == 'String' %}{{field.name}}.as_ref().to_string(){% else %}{{field.name}}{% endif %});
    self
  }
  {% endif %}{% endif %}{% endfor %}

  {% for field in td.fields %}{% if not field.native %}{% if field.name != 'td_name' %}
  // [{{field.name}}] type is [{{field.class_real}}], is not support, need add manully.
  #[doc(hidden)] pub fn _{{field.name}}(&mut self, {{field.name}}: {{field.class_real}}) -> &mut Self {
    self.inner.td_origin_mut()._set_{{field.name}}({{field.name}});
    self
  }
  {% endif %}{% endif %}{% endfor %}
}

impl {{tgype.typen}} {
  pub fn builder() -> _{{tgype.typen}}Builder {
    _{{tgype.typen}}Builder { inner: Self::new({{tgype.inner}}::_new()) }
  }
}

impl TDFB for TG{{td.clz_name}} {}

impl AsRef<{{tgype.typen}}> for {{tgype.typen}} {
  fn as_ref(&self) -> &{{tgype.typen}} { self }
}

impl AsRef<{{tgype.typen}}> for _{{tgype.typen}}Builder {
  fn as_ref(&self) -> &{{tgype.typen}} { &self.inner }
}
